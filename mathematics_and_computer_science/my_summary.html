<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<head>
<title>Mathedemo</title>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['<br>(','<br>)']]}});
</script>
<script type="text/javascript"
  src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
</head>

<body>

<!-- credits: https://tex.stackexchange.com/questions/23804/how-to-incorporate-tex-into-a-website -->
<h2>Math in TeX notation</h2>


<h1>Chapter: Mathematics </h2>
<h2>Logic</h2>

<h3>Truth Value</h3>
<p>An Assertion is an Object which has a truth value, is either true or false, 1 or 0 

<h4>Negation</h4>
<p>
    Is A an assertion, and is true, so is $ \neg A $ false.
</p>
</p>
 
<h3>Conjunction, Disjunction</h3>
<p>
Are A and B assertions, then the Conjunction of A and B is $ A \wedge B $
is true if A and B are true.
</p>
<p> 
Are A and B assertions, then the Disjunction of A and B: 
$ A \vee B $
 is true if either A is true or B is true.
</p> 
<h2> Quantoren</h2>

<h4>Existence</h4>
<p>
 we write 
$ \exists $ to say that there is something that has some propertie(s).<br>
We write $ \exists ! $ to say there exists just one thing with that property.<br>
We write $ \forall $ to say that for all objects specified, some proposition is true.
</p>


<p>
Are A and B assertions, we write $ A \Rightarrow B $
 for "A implies B" and call this implication. <br>
 The only case where this statement is false is if A is true and B is false.
</p>
<p>
If $ A \Rightarrow B $
 and $ B \Rightarrow A  $
 are true, we write $ A \Leftrightarrow B $
and call this equivalence.
</p>

<p>
We write $ x:=y$  to say that x is defined in terms of y.<br>
We write $ :$ to say that the statement to the right of this sign holds true for the things on the left of this sign.
</p>
<br>

<h2> Sets </h2>

A Set is a collection of distinct Objects to a whole. These Objects can have any form. If a Set has no elements, we call it the empty set $
 \emptyset $

If x is Element of the Set A, we write $ x \in A $ , if x is not Element of Set A, $ x \not\in A $

Subset
<br>

A is called a subset of B, written $
 A \subset B
$ if and only if $
 x \in A \Rightarrow x \in B
$ 
$
 A \not\subset B
$ is defined as : $ \exists x \in A : x \not\in B $
Definition: the Cut of two Sets A, B is defined as:
$
 A \cap B := \lbrace x : x\in A \wedge x \in B \rbrace
$
Two Sets are called disjoint, if $
 A \cap B = \emptyset
$
Definition: Joining of two Sets:<br>
The joining of two sets A,B is defined as $$
 A \cup B := \lbrace x : x \in A \vee x \in B \rbrace
$$
Disjunct joining means joining two or more sets where they have no elements in common. TODO: expand on this like in the book
Definition: Difference of two sets:
$$
 A \backslash B := \lbrace x : x \in A \wedge x \not\in B \rbrace
$$
Definition: Symmetric Difference:
$$
 A \bigtriangleup B := (A \backslash B) \cup (B \backslash A)
$$
Definition: Potenzmenge:
$$
P(M) := \lbrace A : A \subset P \rbrace
$$
The Potenzmenge is the set of all subsets of M.<br>
Definition: Cartesian Product:<br>
The cartesian Product of the sets $$ A_{1}, ... , A_{n}
$$ is defined as
$$
 A_{1} \times ... \times A_{n} := \lbrace (a_{1}, ... ,a_{n}) : a_{i} \in A_{i} : \forall i = \lbrace 1,...,n\rbrace \rbrace
$$
Are $ A_{1} = ... = A_{n} $
we can also write $ A^{n} $
obere und untere Schranke:

<h2> Function, Relations </h2>
Function:
Are A, B sets then a function f from A to B is a function that 
maps every $ a \in A $ to some $ b \in B $

We write for a function from A to B:
$$
    f: A \rightarrow B, a \mapsto f(a)
$$

Definition: Bild, Urbild: (TODO)

<h2>Numbers</h2>
<h2>Proof Techniques</h2>
direct Proof:
Man geht von der (gegebenen, wahren) Vorraussetzung (Aussage) A aus und zeigt durch Umformungen oder Folgern, dass aus A die Aussage B folgt. Mathematisch ausgedrueckt untersucht man $ A \Rightarrow B $

 indirect Proof:
Der indirekte Beweis ist einer der elegantesten und auch einfachsten Beweise. Man geht dabei so vor: <br>
1. Man geht von Gegenteil der Behauptung aus (dies ist die Annahme).<br>
2. Man versucht diese Annahme zu einem Widerspruch zu fuehren.<br>
3. Wenn der Beweisgang legitim und logisch war, muss die Annahme falsch gewesen sein und damit die Behauptung wahr.<br>
Definition: Induction:<br>
Wir moechten uns der vollstaendingen Induktion nun mithilfe der sogenannten Peano-Axiome annaehern, die folgendes besagen:<br>
TODO: continue here

\section{Analysis}
Sei M eine Menge. Eine Metrik ist eine abbildung $ d: M x M \rightarrow R $ auf M x M fuer die folgende 3 Axiome definiert sind: 
Positiv definiertheit, $
 \forall x,y \in M gilt d(x,y) >=0 $  Gleichheit gilt wenn $ x=y $
und Symmetrie, Es gilt d(x,y) = d(y,x) fuer alle x,y in M.
und Dreiecksungleichung. Es gilt:
$$
 d(x,y) <= d(x,z) + d(z,y) \forall x,y,z \in M
$$
Das Paar (M,d) nennt man einen metrischen Raum.

Definition offene Kugel, abgeschlossene Kugel
Seien (M,d) ein metrischer Raum, $
 x_{0} \in M , r>0
$ Die Menge $
 U(x_{0},r):={x\in M : d(x,x_{0})<r}
$ bezeichnen als d-offene Kugel.
Die Menge 
$$
 B(x_{0},r):={x\in M : d(x,x_{0})\leq r}
$$ bezeichnen also d-abgeschlossene Kugel.

Definition Umgebung
Sei (M,d) ein metrischer Raum. Eine Teilmenge $
 U \subset M 
$ is called Environment (Umgebung) of a  Point $
 x \in M 
$ if $
 \epsilon > 0 ex. sodass U(x,\epsilon) \subset U
$
Insbesondere ist $
 U(x,\epsilon) $
 selbst eine Umgebung von x.
 Man nennt $
  U(x,\epsilon) die \epsilon Umgebung von x.
$
<h2> Programming </h2>
<h3> Linux </h3>
<p>
read: man pages for: pwd, touch,cat,mkdir,cd,ls,ech,file
</p>

<h3>vim (neovim)</h3>
<p> read: man vim </p>

<h3>Git and Github</h3>

<p> read: man git </p>
  
<h3>C</h3>
(TODO)
<h2>Java</h2>
<p>
.java files are compiled by javac into jvm bytecode in .class files.
These can be interpreted by the Java VirtualMachine.<br>
The .java File always has to be the same name as the class.
</p>

<code>
//Example.java<br>
public class Example{<br>
    //...<br>
}
</code>
<br>

<h3>Arithmetic, Comparison</h3>

The == operator checks if primitive data types like ints are equal.<br>
It checks Objects for reference equality.<br>
The .equals() method checks 2 Objects for value equality.<br>

<h3>Operator Reference</h3>

<code>
    Operator & How to write <br>
    postfix & expr++ expr-- <br>
    unary & ++expr --expr -expr +expr <br>
    multiplicative & * /  <br>
    additive & + - <br>
    shift & \<< \>> \>>> <br>
    relational & < > <= >= instanceof<br>
    equality & == !=<br>
    bitwise and & \&<br>
    bitwise XOR & |<br>
    logical and & "&&"<br>
    logical or & ||<br>
    ternary & ? : <br>
    assignment & = += -= *= /= \%= \&= ^= <<= >>= >>>= <br>
    
</code>
<h3>Data Types</h3>
There is a difference between primitive Data Types and Class Tyes<br>

Integer <-> int<br>
Character <-> char<br>
Double <-> double<br>

I only included the methods and classes i thought were most useful<br>
These methods are battle tested and should work reliably. Simple and primitive data structures are <br>
better if there is a way to use them. Writing your own data types should be a last resort.<br>

java.net<br>
java.util<br>
java.util.ArrayList<br>
java.util.Collections<br>

<h4>java.lang.String</h4>
<code>
.indexOf(String s)              //returns int<br>
.lastIndexOf(String s)          //returns int<br>
.split(String regex)            //returns String[]<br>
.substring(int begin,int end)   //returns String<br>
.toCharArray()                  //returns char[]<br>
.toLowerCase()                                  <br>
.toUpperCase()                                  <br>
.trim()                     //leading and trailing whitespace removed<br>
.length()           <br>
.charAt(int index)<br>
.contains(String match)<br>
.equals()
</code>


Arrays.asList(T... a) <br>
Arrays.sort(T[] arr)   <br>
Arrays.toString() <br>
<br>
//returns the index of the key if found or -1 if not found<br>
Arrays.binarySearch(T... a, T key) <br>
<br>
Arrays.copyOfRange(int from,int to)  <br>
Arrays.deepEquals(T[] a,T[] b) <br>
Arrays.fill(T[] arr, T value) <br>


<h3>java.util.LinkedList</h3>
<code>
new LinkedList();<br>
.add(E e);<br>
.addFirst(E e);<br>
.addLast(E e);<br>
.clear();<br>
.contains(Object o);<br>
.element();<br>
.get(int index);<br>
.getFirst();<br>
.getLast();<br>
.indexOf(Object o);<br>
.lastIndexOf(Object o);<br>
.pop();<br>
.push(E e);<br>
.size();<br>
</code>

<h3>java.util.Stack}</h3>


new Stack();
.empty();
.peek();
.pop();
.push(Object o);
.search(Object o); //returns the 1 based position of the item on the stack




<h3>java.util.HashMap</h3>

//these methods are defined on objects of type HashMap. <br>
.clear() //removes all mappings<br>
.containsKey(Object key) //returns true if the key is in the map<br>\
.get(Object key) //returns the value to which the key is mapped<br>
.put(Object key, Object value) //makes a new entry for the key,value pair<br>
.remove(Object key) //removes the key and its value<br>
.size() 



<h1>Algorithms</h1>
<h2>O Kalkuel</h2>
To calculate the growth of runtime depending on input size, these rules can be used.<br>

Different Running time classes:
O(1),O(n),O(n log n),O(n squared), O(n cubed), O(x to the n)

\section{Sorting}
\subsection{Insertion Sort}
Insertion sort builds a sorted subarray by inserting the elements into the right place in that array. 
In this way the array grows and in the end the entire array is sorted.
Running time in O(n**2)
\subsection{Selection Sort}
This works by choosing the smallest element in our nonsorted subarray, removing it and inserting it at the end of our sorted subarray.
Running time is in O(n**2)
\subsection{Bubble Sort}
Bubble sort is in O(n*n)
it works by looping through the list and swapping two elements if the right neigbor of an element is smaller
than the element itself.
\subsection{Heap Sort}
Heap Sort consists of building a max-heap,
then popping of the first(greatest element and putting it at the end of our sorted array.
This algorithm can work in-situ and has a running time of O(n log(n))

\subsection{Quicksort}
Quicksort is of the same running time as mergesort, with the advantage of it being in-situ, meaning it is nonrecursive and doesnt need more than a fixed amount of additional memory.
\subsection{Mergesort}
Mergesort splits the array in 2 arrays until they have length 1. Then it recursively merges them into one sorted array.
\subsection{Counting Sort}
\subsection{Radixsort}

Bucketsort<br>
Searching<br>
Binary Search<br>
for searching a sorted array, running time in O(log(n))<br>
Linear Search}<br>
just search the entire input from beginning to end. Running time in O(n)<br>

<h3>Searching in Texts</h3>

Gegeben: Zeichensatz Z, T= a0,...,a n-1 mit a i elem. Z
und Muster P = b0, ... ,b m-1 mit b i elem Z

Aufgabe: Berechne i elem N 0 mit 
0 <= i <= n-m und i ist die Anfangsposition  <br>
des Musters P im Text T, d.h., ai=b0, ai+1=b1, ... , a i+m-1 =b m-1 oder <br>
i=n falls das Muster P nicht im Text T enthalten ist.
\subsection{Naive Suche}
Methode: <br>
Durchsuche den gesamten Text schrittweise von links nach rechts und vergleiche bei jeder Position von links das Muster zeichenweise
mit dem Text.
Vergleiche das Zeichen im Text auf Position i + j mit dem Zeichen im
Muster auf Position j f??r i = 0, . . . , n ??? m und j = 0, . . . , m ??? 1.
Verschiebe das Wort bei einem Mismatch um eine Position nach rechts.
Erh??he i auf i + 1 und wiederhole der Vergleich f??r j = 0, . . . , m ??? 1.
Wurde ein Vorkommen des Musters im Text gefunden, gebe den Index i
zur??ck, ansonsten n
<code>
int naive search (char T [ ], int n, char P[ ], int m)
{
    if ((m > 0) ??? (n ??? m)) {
        int i := 0;
        int j := 0;
        while ((i <= n ??? m) ??? (j <= m ??? 1)) {
            if (T [i + j] = P[j]) {
                j + +;
            }
            else {
                i := i + 1;
                j := 0;
            }
        }
        if (j = m) {
            return(i);
        }
    }
    return(n);
}
</code>
Analyse: Der naive Algorithmus f??hrt im ung??nstigsten Fall
(n ??? m + 1) ?? m ??? O(n ?? m)
viele Vergleiche durch.

\subsection{Knuth Morris Pratt}
Das Verfahren von Knuth-Morris-Pratt:<br>
Methode: <br>
Vergleiche das Zeichen im Text auf Position i mit dem Zeichen
im Muster auf Position j.
Wenn das Zeichen im Text auf Position i mit dem Zeichen im Muster auf
Position j ??bereinstimmt, dann erh??he i und j um 1.
Wenn das Zeichen im Text auf Position i mit dem Zeichen im Muster auf
Position j nicht ??bereinstimmt, dann setze j auf die gr????te Position l
zwischen 0 und j ??? 1 zur??ck, so das b 0 , . . . , b l???1 = a i???l , . . . , a i???1 .
<br>
Speichere diese Positionen im next-Array.

Berechnung des next arrays<br>
\begin{verbatim}

void init next array (int next[ ], char P[ ], int m)
{
    if (m > 0) {
        int i := 0;
        int j := ???1;
        next[0] := ???1;
        while (i < m ??? 1) {
            if ((j = ???1) ??? (P[i] = P[j])) {
                i + +;
                j + +;
                next[i] := j; }
            }else {
                j := next[j];
            }
        }
    }
}
\end{verbatim}
Textsuche mit berechneten next array
<br>
\begin{verbatim}
int kmp search (char T [ ], int n, char P[ ], int m, int next[ ])
{
    if ((m > 0) ??? (n ??? m)) {
        int i := 0;
        int j := 0;
        while ((i < n) ??? (j < m)) {
            if ((j = ???1) ??? (T [i] = P[j])) {
                i + +;
                j + +;
            }else{
                j := next[j];
            }
        }
        if (j = m) {
            return(i ??? m);
        }
    }
    return(n);
}
\end{verbatim}

Analyse:<br>
Variable j kann nur so oft erniedrigt werden, wie sie zuvor erh??ht wurde.
Variable j wird immer zusammen mit Variable i erh??ht.
Also wird j nur so oft erniedrigt, wie i erh??ht wird.
Ist das next-Array bekannt, so hat das Verfahren eine lineare Laufzeit
O(n).
Da das next-Array in O(m) Schritten aufgebaut werden kann, ben??tigt
der gesamte Algorithmus O(n + m) Schritte.<br>
Verbessertes next-Array
Das verbesserte next-Array next???[ ] ber??cksichtig zus??tzlich die
Information, dass im Text ein Zeichen steht, dass dem Zeichen im Wort
nicht entspricht.
<br>
Berechnung des next' Arrays
\begin{verbatim}
void init next array (int next 0 [ ], char P[ ], int m)
{
    if (m > 0) {
    int i := 0;
    int j := ???1;
    next 0 [0] := ???1;
        while (i < m ??? 1) {
            if ((j = ???1) ??? (P[i] = P[j])) {
                i + +;
                j + +;
                if (P[i] = P[j]) {
                    next 0 [i] := next 0 [j];
                }else {
                    next 0 [i] := j;
                }
            }else {
                j := next 0 [j];
            }
        } 
    } 
}
\end{verbatim}
\subsection{Boyer and Moore}
\textbf{Das Verfahren von Boyer-Moore: }
Methode:
Bei dem Verfahren von Boyer und Moore werden die Zeichen im Muster
von rechts nach links mit den Zeichen im Text verglichen.
Variable i kennzeichnet die Stelle im Text, die mit dem letzten Zeichen
im Muster verglichen wird.
Variable i beginnt bei m ??? 1 und erh??ht sich bis maximal auf n ??? 1.
Verglichen werden die Zeichen T [i ??? j] und P[(m ??? 1) ??? j] f??r
j = 0, . . . , m ??? 1.
Kommt es beim Vergleich der Zeichen zu einem Mismatch, dann wird
das Muster so weit wie m??glich nach rechts verschoben, jedoch maximal
um die Musterl??nge.

\begin{verbatim}
int bm suche (char T [ ], int n, char P[ ], int m)
{
    if (m > n) {
        return (n);
    }
    int i := m ??? 1;
    int j := 0;
    while ((j ??? m ??? 1) ??? (i ??? n ??? 1)) {
        if (T [i ??? j] = P[(m ??? 1) ??? j]) {
            j + +;
        }else {
            i := i + "Musterverschiebung";
            j := 0;
        }
    }
    if (j > m ??? 1) {
        return (i ??? (m ??? 1));
    }else {
        return (n);
    }
}
\end{verbatim}
In Zeile 13 ist beim vereinfachten Verfahren von Boyer und Moore die
Musterverschiebung 
$$
	1,= max.delta(T [i ??? j]) ??? j
$$
Beachte:
$
???j ??? delta(T [i ??? j]) ??? j ??? m
$

Bemerkungen:
Kommt es zu einem Mismatch zwischen T [i ??? j] und P[(m ??? 1) ??? j],
dann wird das Muster so weit nach rechts verschoben, bis das Zeichen
T [i ??? j] im Text ??ber dem rechtesten Vorkommen von T [i ??? j] im
Muster P steht.<br>

Kommt das Zeichen T [i ??? j] im Muster gar nicht vor, dann wird das Muster um seine gesamte L??nge verschoben.
Das Muster wird jedoch mindestens um eine Position nach rechts geschoben.
Obwohl obiges Verfahren eine worst-case-Laufzeit von O(n ?? m) hat
(Beispiel: T = 00 ?? ?? ?? 0, P = 100 ?? ?? ?? 0), hat es sich in der Praxis
ausgezeichnet bew??hrt.
F??r gen??gend kurze Muster und hinreichend gro??e Zeichens??tze werden
im Mittel O(n/m) viele Schritte durchgef??hrt.
Das Muster wird dann also nahezu immer um seine Gesamtl??nge nach
rechts verschoben.<br>

Kleine Modifikationen
Der delta-Wert f??r das letzte Zeichen P[m ??? 1] im Muster P kann auch
auf das zweite Vorkommen des Zeichens im Muster (von rechts gez??hlt)
gesetzt werden, da ein delta-Wert von 0 einer Musterverschiebung von 0
entspricht.<br>

Jetzt wird das Muster so weit nach rechts geschoben, dass das zweite
Vorkommen von rechts des letzten Zeichens im Muster mit der Position
i ??? j im Text verglichen wird.
Musterverschiebung
= max
1,
delta???(T [i ??? j]) ??? j
21 / 38Suchen in Texten - Boyer-Moore
Falls j > 0 ist, kann das Muster auch um delta???(P[m ??? 1]) verschoben
werden.
Hier wird das zweite Vorkommen von P[m ??? 1] der Position i im Text
zugeordnet. Das macht jedoch nur Sinn, wenn dieses Zeichen dort im
Text auch steht, also wenn T [i] = P[m ??? 1] ist, was der Fall sein muss,
wenn j bereits gr????er als 0 ist.
Musterverschiebung
1,
delta???(T [i ??? j]) ??? j,
= max
delta???(P[m ??? 1]) falls j > 0
22 / 38Suchen in Texten - Boyer-Moore
Das Muster kann auch um delta(T [i + 1]) + 1 erh??ht werden.
Hier wird das Zeichens im Text auf Position i + 1 betrachtet und dem
ersten Vorkommen von rechts im Muster zugeordnet.
Musterverschiebung
1,
delta???(T [i ??? j]) ??? j,
= max
delta???(P[m
??? 1]) falls j > 0,
delta(T [i + 1]) + 1
23 / 38Suchen in Texten - Boyer-Moore
Verbesserung des einfachen Verfahrens von Boyer und Moore
Die Sub-Muster im Muster k??nnen ??hnlich wie bei dem Verfahren von
Knuth Morris und Pratt mit ber??cksichtigt werden.
Genutzt wird die Information, dass auf den Positionen
i, i ??? 1, . . . , i ??? (j ??? 1) im Text die gleichen Zeichen stehen, wie im
Muster auf den Positionen (m ??? 1), (m ??? 1) ??? 1, . . . , (m ??? 1) ??? (j ??? 1).
Die Musterverschiebung wird abh??ngig von j in einem beta-Wert
gespeichert.
Wird zus??tzlich noch die Information genutzt, dass auf Position i ??? j im
Text ein anderes Zeichen steht als auf Position (m ??? 1) ??? j im Muster,
dann ist es der verbesserte beta-Wert.<br>

Die beta Musterverschiebung f??r Muster P mit einem Mismatch bei j,
das hei??t T [i ??? j] 6 = P[(m ??? 1) ??? j], ist der Wert beta(j).<br>

Es ist die kleinste Zahl k zwischen 1 und m ??? 1, sodass f??r
l = 0, 1, . . . , l Ende
P[(m ??? 1) ??? l]
=/=
P[(m ??? 1) ??? k ??? l].<br>

Der Endwert l Ende f??r den Laufindex l ist das Minimum von
1 j ??? 1, da nur j ??? 1 Zeichen links der Position i im Text mit den
Zeichen links der letzten Position m ??? 1 im Muster ??bereinstimmen,
und
2 (m ??? 1) ??? k, da ansonsten (m ??? 1) ??? k ??? l kleiner 0 ist.
l Ende = min{j ??? 1, (m ??? 1) ??? k}
Falls es keine solche Zahl k gibt, ist die Musterverschiebung 1.
25 / 38Suchen in Texten - Boyer-Moore
Musterverschiebung

1,
delta???(T [i ??? j]) ??? j,
delta???(P[m ??? 1]) falls j > 0,
= max
delta(T
[i + 1]) + 1,
beta(j)

Wird zus??tzlich noch P[(m ??? 1) ??? j] 6 = P[(m ??? 1) ??? k ??? j] ber??cksichtigt,
dann erh??lt man den verbesserten beta???-Wert.
Musterverschiebung
1,
delta???(T [i ??? j]) ??? j,
delta???(P[m ??? 1]) falls j > 0,
= max
delta(T
[i + 1]) + 1,
beta 0 (j)<br>
Bemerkungen:
Der beta-Wert beseitigt zwar die worst-case Instanzen bei der Textsuche
(hier ohne Beweis), bringt aber in der Praxis eigentlich nichts. Deshalb
wird in der Regel mit der vereinfachten Version gearbeitet.
\section{Vorlesung 5: Hash Verfahren}
Beim Hashing werden die Schluessel der Objekte zur Berechnung einer Position in einem Feld verwendet.

Sei K eine Schluesselmenge und I eine eindeutige Indexmenge.

(In der Regel $$
I =\lbrace0,...,m-1\rbrace
$$
wobei m die feldgroesse ist.)<br>
Die Hash funktion <br>
\textbf{h: K-> I}
wird zum Suchen und platzieren von Elementen eingesetzt.
Sie soll die Schluessel gleichmaessig auf die Indizes verteilen.<br>
Wenn mehrere Schluessel auf einen Index abgebildet werden, ist das eine Kollision.
Bei einer Kollision muss ein Ersatzplatz gefunden werden.<br>
Welche Funktionen sind als Hash Funktionen geeignet?<br>
Ausblenden und Restbilden. <br>
Ausblenden: benutze nur einen Teil des schluessels(nicht alle stellen)
Restbildung: Der schluessel k wird ganzzahlig durch die laenge der Hashtabelle dividiert.
Der Rest wird als Index verwendet.<br>
$$
h(k)=k mod \mid l \mid
$$

Die besten Ergebnissze erhaelt man wenn l eine primzahl ist.
Schluessel die nicht als zahlen interpretiert werden koennen, werden vorher geeignet umgerechnet.
\subsection{Universelle Hash funktionen}
Gesucht sind Hashfunktionen die im mittel akzeptabel sind.<br>
Sei 
$$
	m=\mid I \mid und H eine endliche Menge von >= m Hash Funtkionen. 
$$
H heisst Universell wenn fuer jedes Paar von verschiedenen Schluesseln 
$
x,y \in K gilt:
$
<br>
$$
\mid\lbrace h \in H \mid h(x)=h(y) \rbrace \mid \leq \lceil \frac{\mid H \mid}{m} \rceil
$$
Fuer jedes Schluesselpaar x,y fuehrt hoechstens der m-te Teil der Hash Funktionen die beiden schluessel x,y zu einer Kollision.<br>
Die Wahrscheinlichkeit dass zwei Schluessel mit einer Hash Funktion aus H auf den gleichen Index abgebildet werden ist <!-- begin MathToWeb -->
<!-- (your LaTeX) \begin{math} \frac{1}{m} \end{math} -->
<math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow>
	<mfrac linethickness="1">
		<mn>1</mn>
		<mi>m</mi>
	</mfrac>
</mrow>
</math>
<!-- end MathToWeb --><br>
Sei
$
p \geq m
$
eine Primzahl und <br>
$$
h(a,b) : \lbrace 0,...,p-1\rbrace \mapsto \lbrace 0,...,m-1 \rbrace 
$$
mit
$$
\textbf{ha,b(x)=((ax + b) mod p) mod m}
$$
Dann ist 
$$
\lbrace h a,b \mid 1 \leq a < p, 0 \leq b < p \rbrace
$$
eine universelle Klasse von Hash Funktionen (lineare Algebra)<br>
\subsection{Kollisionsaufloesung}
Probleme treten auf bei der Platzierung, wenn der berechnete Platz nicht leer ist und bei der Suche, wenn der berechnete Platz ein anderes Element enthaelt.<br>
Zur Kollisionsaufloesung muss ein ersatzplatz gefunden werden.
\subsubsection{1. Verkettung der Ueberlaeufer}
Die Ueberlaeufer, die auch auf diesen schon besetzten Platz platziert werden sollen, koennen z.b.
in einer linearen Liste verkettet werden, welche an den Hashtabelleneintrag angehaengt wird, der sich aus der Hash Funktion angewendet auf den Schluessel ergibt.<br>
Bei einer erfolglosen Suche nach schluessel k betrachten wir alle Elemente in der Liste an h(k)<br>
Die durchschnittliche Anzahl der Eintraege in h(k) ist n/m wenn n Eintraege auf m Listen verteilt sind.
\textbf{Belegungsfaktor <!-- begin MathToWeb -->
<!-- (your LaTeX) \begin{math}\alpha = n/m\end{math} -->
<math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow>
	<mi>&#x003B1;</mi>
	<mo>=</mo>
	<mi>n</mi>
	<mo>&#x0002F;</mo>
	<mi>m</mi>
</mrow>
</math>
<!-- end MathToWeb -->}

Im Mittel ist die Anzahl der bei der erfolglosen Suche nach einem Schluessel betrachteten Eintraege also 
<!-- begin MathToWeb -->
<!-- (your LaTeX) \begin{equation}
C n=\frac{n}{m}=\alpha
\end{equation} -->
<math xmlns="http://www.w3.org/1998/Math/MathML">
<mtable class="m-equation" displaystyle="true" style="display: block; margin-top: 1.0em; margin-bottom: 2.0em">
	<mtr>
		<mtd>
			<mspace width="6.0em" />
		</mtd>
		<mtd columnalign="left">
			<mi>C</mi>
			<mi>n</mi>
			<mo>=</mo>
			<mfrac linethickness="1">
				<mi>n</mi>
				<mi>m</mi>
			</mfrac>
			<mo>=</mo>
			<mi>&#x003B1;</mi>
		</mtd>
		<mtd columnalign="right" style="width: 100%">
			<mtext id="">(1)</mtext>
			<mspace width="6.0em" />
		</mtd>
	</mtr>
</mtable>
</math>
<!-- end MathToWeb -->
Beim einfuegen des j-ten Schluessels ist die durchschnittliche Listenlaenge gerade (j-1)/m<br>
Also betrachten wir bei einer spaeteren Suche nach dem j-ten Schluessel gerade 1+(j-1)/m Eintraege im Durchschnitt, wenn stets am Listenende eingefuegt wird und kein Datensatz entfernt wurde.<br>
Im Mittel ist die Anzahl der bei der erfolgreichen Suche nach einem Schluessel betrachteten Eintraege also
$$
C _{n} = \frac{1}{n}\sum _{j=1} ^{n} (1+(j-1)/m) = 1 + \frac{n-1}{2m} \approx 1+ \frac{\alpha}{2}
$$
\subsubsection{2. Offene Hash Verfahren}
Speichere die Ueberlaeufer in der Hashtabelle und nicht in zusaetzlichen Listen. Nur sinnvoll fuer <!-- begin MathToWeb -->
<!-- (your LaTeX) \begin{math}\alpha < 1\end{math} -->
<math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow>
	<mi>&#x003B1;</mi>
	<mo>&#x0003C;</mo>
	<mn>1</mn>
</mrow>
</math>
<!-- end MathToWeb --><br>
Ist die Hash Addresse h(k) belegt, so wird eine Ausweichposition gesucht.
\textbf{Die Folge der zu betrachtenden Speicherplaetze fuer einen Schluessel nennt man Sondierungsfolge}<br>
Sei <!-- begin MathToWeb -->
<!-- (your LaTeX) \begin{math}h:K \rightarrow \lbrace 0,...,m-1 \rbrace \end{math} -->
<math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow>
	<mi>h</mi>
	<mo>:</mo>
	<mi>K</mi>
	<mo>&#x02192;</mo>
	<mrow>
		<mo form="prefix">&#x0007B;</mo>
		<mn>0</mn>
		<mo>,</mo>
		<mo>.</mo>
		<mo>.</mo>
		<mo>.</mo>
		<mo>,</mo>
		<mi>m</mi>
		<mo>-</mo>
		<mn>1</mn>
		<mo form="postfix">&#x0007D;</mo>
	</mrow>
</mrow>
</math>
<!-- end MathToWeb --> eine Hash Funktion und <!-- begin MathToWeb -->
<!-- (your LaTeX) \begin{math}s:\lbrace 0,...,m-1 \rbrace \times K \rightarrow N0 \end{math} -->
<math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow>
	<mi>s</mi>
	<mo>:</mo>
	<mrow>
		<mo form="prefix">&#x0007B;</mo>
		<mn>0</mn>
		<mo>,</mo>
		<mo>.</mo>
		<mo>.</mo>
		<mo>.</mo>
		<mo>,</mo>
		<mi>m</mi>
		<mo>-</mo>
		<mn>1</mn>
		<mo form="postfix">&#x0007D;</mo>
	</mrow>
	<mo>&#x000D7;</mo>
	<mi>K</mi>
	<mo>&#x02192;</mo>
	<mi>N</mi>
	<mn>0</mn>
</mrow>
</math>
<!-- end MathToWeb --> eine Funktion sodass fuer jedes <!-- begin MathToWeb -->
<!-- (your LaTeX) \begin{math} k \in K \end{math} -->
<math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow>
	<mi>k</mi>
	<mo>&#x02208;</mo>
	<mi>K</mi>
</mrow>
</math>
<!-- end MathToWeb --> , die Folge (h(k) - s(j,k)) mod m fuer j=0,1,...,m-1 eine Permutation aller Hash Addressen 0,...,m-1 ist, dann ist s eine Sondierungsfunktion fuer h.<br>

\underline{Lineares Sondieren}<br>
Beim linearen Sondieren ist fuer Schluessel k die Sondierungsfolge h(k), h(k)-1, h(k)-2 ,...,0,m-1,...,h(k)+1 <br>
Die Sondierungsfunktion ist damit <!-- begin MathToWeb -->
<!-- (your LaTeX) \begin{equation}
s(j,k)=j
\end{equation} -->
<math xmlns="http://www.w3.org/1998/Math/MathML">
<mtable class="m-equation" displaystyle="true" style="display: block; margin-top: 1.0em; margin-bottom: 2.0em">
	<mtr>
		<mtd>
			<mspace width="6.0em" />
		</mtd>
		<mtd columnalign="left">
			<mi>s</mi>
			<mrow>
				<mo form="prefix">(</mo>
				<mi>j</mi>
				<mo>,</mo>
				<mi>k</mi>
				<mo form="postfix">)</mo>
			</mrow>
			<mo>=</mo>
			<mi>j</mi>
		</mtd>
		<mtd columnalign="right" style="width: 100%">
			<mtext id="">(1)</mtext>
			<mspace width="6.0em" />
		</mtd>
	</mtr>
</mtable>
</math>
<!-- end MathToWeb -->
\underline{Nachteil}<br>
Das Verfahren neight zur \underline{primaeren Haeufung}, indem gewisse Bereiche keine Luecke mehr aufweisen.<br>
\underline{Quadratisches Sondieren}<br>
Es wird um h(k) herum mit quadratisch wachsendem Abstand nach einem freien Platz gesucht.<br>
Sondierungsfolge: h(k), (h(k)=1) mod m, (h(k) -1) mod m, (h(k) +4 ) mod m, (h(k) -4) mod m, ... <br>
Sondierungsfunktion: <br>
<!-- begin MathToWeb -->
<!-- (your LaTeX) \begin{equation}
s(j,k) = (\lceil j/2 \rceil)^{2} (-1)^{j}
\end{equation} -->
<math xmlns="http://www.w3.org/1998/Math/MathML">
<mtable class="m-equation" displaystyle="true" style="display: block; margin-top: 1.0em; margin-bottom: 2.0em">
	<mtr>
		<mtd>
			<mspace width="6.0em" />
		</mtd>
		<mtd columnalign="left">
			<mi>s</mi>
			<mrow>
				<mo form="prefix">(</mo>
				<mi>j</mi>
				<mo>,</mo>
				<mi>k</mi>
				<mo form="postfix">)</mo>
			</mrow>
			<mo>=</mo>
			<msup>
				<mrow>
					<mo form="prefix">(</mo>
					<mrow>
						<mo form="prefix">&#x02308;</mo>
						<mi>j</mi>
						<mo>&#x0002F;</mo>
						<mn>2</mn>
						<mo form="postfix">&#x02309;</mo>
					</mrow>
					<mo form="postfix">)</mo>
				</mrow>
				<mn>2</mn>
			</msup>
			<msup>
				<mrow>
					<mo form="prefix">(</mo>
					<mo>-</mo>
					<mn>1</mn>
					<mo form="postfix">)</mo>
				</mrow>
				<mi>j</mi>
			</msup>
		</mtd>
		<mtd columnalign="right" style="width: 100%">
			<mtext id="">(2)</mtext>
			<mspace width="6.0em" />
		</mtd>
	</mtr>
</mtable>
</math>
<!-- end MathToWeb -->
Wenn m eine Primzahl der Form 4i+3, <!-- begin MathToWeb -->
<!-- (your LaTeX) \begin{math}i \in N \end{math} -->
<math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow>
	<mi>i</mi>
	<mo>&#x02208;</mo>
	<mi>N</mi>
</mrow>
</math>
<!-- end MathToWeb -->ist, dann ist garantiert, <br>
dass die Sondierungsfunktion Modulo m eine Permutation der Hash Addressen 0 bis m-1 ist.

\underline{Nachteil}<br>
Zwei Schluessel k und k' mit h(k) = h(k') durchlaufen stets dieselbe Sondierungsfolge. Sie behindern sich also auf Ausweichplaetzen (sekundaere haeufung)


\subsubsection{Double Hashing}
\underline{Verbesserte Kollisionsaufloesung}
Schluesselabhaengige Sondierung (double Hashing):
Verwende fuer die Sondierungsfolge eine zweite Hash Funktion h' <br>
Sondierungsfolge:
h(k), (h(k) -h'(k)) mod m, (h(k) -2*h'(k)) mod m, ..., (h(k) -(m-1) * h'(k)) mod m<br>
Sondierungsfunktion:
<!-- begin MathToWeb -->
<!-- (your LaTeX) \begin{equation}
s(j,k)=j*h'(k)
\end{equation} -->
<math xmlns="http://www.w3.org/1998/Math/MathML">
<mtable class="m-equation" displaystyle="true" style="display: block; margin-top: 1.0em; margin-bottom: 2.0em">
	<mtr>
		<mtd>
			<mspace width="6.0em" />
		</mtd>
		<mtd columnalign="left">
			<mi>s</mi>
			<mrow>
				<mo form="prefix">(</mo>
				<mi>j</mi>
				<mo>,</mo>
				<mi>k</mi>
				<mo form="postfix">)</mo>
			</mrow>
			<mo>=</mo>
			<mi>j</mi>
			<mo>*</mo>
			<mi>h</mi>
			<mo>'</mo>
			<mrow>
				<mo form="prefix">(</mo>
				<mi>k</mi>
				<mo form="postfix">)</mo>
			</mrow>
		</mtd>
		<mtd columnalign="right" style="width: 100%">
			<mtext id="">(1)</mtext>
			<mspace width="6.0em" />
		</mtd>
	</mtr>
</mtable>
</math>
<!-- end MathToWeb -->
Die Funktion h' muss so gewaehlt werden, dass die Sondierungsfolge eine Permutation der Hash addressen ist. Das bedeutet dass <!-- begin MathToWeb -->
<!-- (your LaTeX) \begin{math}h'(k)\not = 0
\end{math} -->
<math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow>
	<mi>h</mi>
	<mo>'</mo>
	<mrow>
		<mo form="prefix">(</mo>
		<mi>k</mi>
		<mo form="postfix">)</mo>
	</mrow>
	\not<mo>=</mo>
	<mn>0</mn>
</mrow>
</math>
<!-- end MathToWeb --> sein muss und m nicht teilen darf.<br>
Ist m eine Primzahl und h(k) = k mod m so erfuellt 
h'(k)=1+(k mod (m-2)) die erwarteten Anforderungen.
<br>
\underline{Verbesserung der erfolgreichen Suche}
Die durchschnittliche Suchzeit bei erfolgreicher Suche variiert bei Hash Verfahren ohne Haeufung mit unterschiedlicher Reihenfolge des einfuegens der Schluessel. <br>
In Faellen in denen wesentlich haeeufiger gesuch als eingefuegt wird, kann es sich lohnen, die Schluessel beim einfugen eines neuen Schluessels so zu reorganisieren dass die Suchzeit verkuerzt wird.<br>
\subsection{Brents Alogrithmus}
\underline{Methode} Einfuegen eines Schluessels k: <br>
Beginne mit Hash Addresse i=h(k). <br>
Falls Position i belegt ist, betrachte die beiden Hash-Addressen b=(i-h'(k)) mod m und b'=(i-h'(k')) mod m, wobei k' der Schluessel auf Hash Addresse i ist.<br>

Ist b eine freie Hash Addresse dann positioniere Schluessel k auf Position b, ansonsten, ist b' eine freie Hash Addresse dann positioniere Schluessel k auf Position i und k' auf Position b', ansonsten fahre fort mit dem Versuch, k auf Posiition i=b zu positionieren.

\section{Vorlesung 6: Suchbaeume}
Ein Element (Knoten) knoten hat eine endliche  Anzahl an Nachfolgern (Soehne)<br>
 
Der Knoten ohne Vater heisst \textbf{Wurzel}
Die Knoten ohne Nachfolger heissen \textbf{Blaetter}

Knoten mit Nachfolger heissen \textbf{innere knoten}<br>

Eine Folge von Knoten <!-- begin MathToWeb -->
<!-- (your LaTeX) \begin{math} u_{1} ,..., u_{k} \end{math} -->
<math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow>
	<msub>
		<mi>u</mi>
		<mn>1</mn>
	</msub>
	<mo>,</mo>
	<mo>.</mo>
	<mo>.</mo>
	<mo>.</mo>
	<mo>,</mo>
	<msub>
		<mi>u</mi>
		<mi>k</mi>
	</msub>
</mrow>
</math>
<!-- end MathToWeb -->wobei ui mit <!-- begin MathToWeb -->
<!-- (your LaTeX) \begin{math}1<=i<=k \end{math} -->
<math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow>
	<mn>1</mn>
	<mo>&#x0003C;</mo>
	<mo>=</mo>
	<mi>i</mi>
	<mo>&#x0003C;</mo>
	<mo>=</mo>
	<mi>k</mi>
</mrow>
</math>
<!-- end MathToWeb --> ein Nachfolger
von u i-1 ist, heisst \textbf{Weg der Laenge k} bzw Weg mit k knoten.
<br>
Baeume in denen jeder innere Knoten genau k Nachfolger hat, heissen \textbf{k-naere Baeume}

Die \textbf{Hoehe eines Baumes} ist die Laenge eines laengsten weges von der Wurzel zu einem Blatt -1<br>
Dies ist die Anzahl der Nachfolger von der Wurzel bis zum Knoten u. Die Wurzel hat die Tiefe 0.
<br>
Auf den Nachfolgern besteht in der Regel eine Ordnung, linker bzw. rechter Nachfolger, oder i-ter Nachfolger usw.
Das sind \textbf{geordnete Baeume}<br>

Ein Baum heisst vollstaendig, wenn alle inneren Knoten die maximal moegliche Anzahl von Nachfolgern und alle Blaetter dieselbe Tiefe haben.
<br>
\textbf{Ein Binaerbaum mit n inneren Knoten hat n+1 Blaetter.}
\textbf{
Seine Hoehe ist maximal <!-- begin MathToWeb -->
<!-- (your LaTeX) \begin{math}{\frac{(n-1)}{2}}\end{math} -->
<math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow>
	<mfrac linethickness="1">
		<mrow>
			<mo form="prefix">(</mo>
			<mi>n</mi>
			<mo>-</mo>
			<mn>1</mn>
			<mo form="postfix">)</mo>
		</mrow>
		<mn>2</mn>
	</mfrac>
</mrow>
</math>
<!-- end MathToWeb --> und mindestens <!-- begin MathToWeb -->
<!-- (your LaTeX) \begin{math} \lceil log(n+1) \rceil \end{math} -->
<math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow>
	<mo form="prefix">&#x02308;</mo>
	<mi>l</mi>
	<mi>o</mi>
	<mi>g</mi>
	<mrow>
		<mo form="prefix">(</mo>
		<mi>n</mi>
		<mo>+</mo>
		<mn>1</mn>
		<mo form="postfix">)</mo>
	</mrow>
	<mo form="postfix">&#x02309;</mo>
</mrow>
</math>
<!-- end MathToWeb -->
}

\textbf{Suchbaeume sind geordnete binaere Baeume die in den inneren Knoten Schluessel (oder Elemente mit Schluesseln) speichern}
<br>
Sei u ein innerer Knoten, der den Schluessel k(u) speichert.
Dann sind alle Schluessel im linken Teilbaum von u kleiner als k(u) und
alle Schluessel im rechten Teilbaum von u groesser als k(u)<br>

Die Blaetter repraesentieren Intervalle zwischen den in den inneren Knoten gespeicherten Schluesseln.<br>
\subsubsection{Einen Schluessel in einem Suchbaum finden}
Beginne bei der Wurzel p und vergleiche x mit dem bei p gespeicherten  Schluessel k(p)<br>
Ist x kleiner als k(p),  Setze die Suche mit dem linken Nachfolger von p fort.<br>
Ist x groesser als k(p), setze die Suche mit dem rechten Nachfolger von p  fort.
<br>
Wird ein Blatt erreicht, ist Schluessel x nicht im Suchbaum gespeichert.
\subsubsection{Einfuegen eines Schluessels x in einen Suchbaum}
Suche den Schluessel x im Suchbaum. Falls x nicht im Suchbaum ist, endet die Suche in einem Blatt.
Fuege dort den schluessel ein und erzeuge 2 neue Blaetter.
<br>
Die Form des dabei enstehenden Suchbaums ist von der Reihenfolge des einfuegens abhaengig

\subsubsection{Entfernen eines Schluessels x in einem Suchbaum}

Suche den Schluessel x im Suchbaum. Falls x im Suchbaum ist,  sei u der Knoten mit k(u)=x.<br>
Sind beide Nachfolger von u Blaetter, dann mache u zu einem Blatt.<br>
Ist ein Nachfolger von ein Blatt, dann mache u zu einem blatt(//tausche mit einem nachfolger und schneide blatt u vom baum)<br>

Ist ein Nachfolger von u ein Blatt und der andere ein innerer Knoten dann haenge den anderen Nachfolger von u an den Vater von u.<br>

Sind beide Nachfolger von u innere Knoten, dann suche im rechten Teilbaum von u den Knoten v mit dem kleinsten Schluessel k(v).
Schluessel k(v) ist immer groesser k(u). Der Knoten v heisst \textbf{symmetrischer Nachfolger} von u. Ersetze k(u) durch k(v) und entferne knoten v . Knoten u kann auch durch den \textbf{ symmetrischen Vorgaenger} von u ersetzt werden. Dies ist der Knoten v im linken Teilbaum von u mit dem groessten Schluessel k(v).<br>
\underline{Durchlaufanforderungen}
Jeder Durchlauf startet an der Wurzel
\underline{Hauptreihenfolge}
Betrachte zuerste den Knoten selbst, dann den linken Teilbaum, dann den rechten Teilbaum.
\underline{Nebenreihenfolge}
Betrachte zuerst den linken Teilbaum, dann den rechten Teilbaum, dann den Knoten selbst.
\underline{Symmetrische Reihenfolge} Betrachte zuerst den linken Teilbaum, dann den Knoten selbst, dann den rechten Teilbaum
TODO: insert example from the slides<br>
\subsection{AVL Baeume}
Der Aufwand der Operationen Suchen, Einfuegen und Entfernen ist im wesentlichen von der hoehe des Baumes abhaengig.
\underline{Ziel: } Die hoehe des Suchbaumes soll auf O(log(n)) beschraenkt werden, damit die Such und Einfuege Operationen 
hoechstens O(log(n)) vergleiche benoetigen.<br>
Ein Suchbaum ist \underline{hoehenbalanciert } wenn fuer jeden inneren Knoten u sich die Hoehe des rechten Teilbaumes von u von der 
Hoehe des linken Teilbaumes von u hoechstens um 1 unterscheidet.<br>

Hoehenbalancierte Baeume werden auch \underline{AVL-Baeume} genannt.(nach den erfindern)<br>
Die hoehenbedingung sichert, dass AVL Baeume mit n inneren Knoten und n+1 Blaettern eine Hoehe aus O(log(n)) haben.
\url{AVL- Baeume}
Ein AVL Baum der Hoehe 1 mit minimaler Blattanzahl hat 2 Blaetter.
Ein AVL Baum der Hoehe 2 mit minimaler Blattanzahl hat 3 Blaetter.

Einen AVL Baum der hoehe h+2 mit minimaler Blattanzahl erhaelt man, wenn ein AVL Baum der hoehe h+1 und einen AVL Baum mit hoehe h,
beide mit minimaler Blattanzahl, wie folgt zu einem Baum der Hoehe h+2 zusammengefuegt wird: <br> 
TODO: minimale Blattanzahl herausfinden was es bedeutet<br>
Ist <!-- begin MathToWeb -->
<!-- (your LaTeX) \begin{math}F_{i}\end{math} -->
<math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow>
	<msub>
		<mi>F</mi>
		<mi>i</mi>
	</msub>
</mrow>
</math>
<!-- end MathToWeb --> die i-te Fibonacci Zahl so hat ein AVL baum der hoehe h mindestens <!-- begin MathToWeb -->
<!-- (your LaTeX) \begin{math}F_{h+2}\end{math} -->
<math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow>
	<msub>
		<mi>F</mi>
		<mrow>
			<mi>h</mi>
			<mo>+</mo>
			<mn>2</mn>
		</mrow>
	</msub>
</mrow>
</math>
<!-- end MathToWeb --> Blaetter.
<br>
Die Anzahl der Blaetter in einem hoehenbalacierten Baum waechst also exponentiell mit der Hoehe. Daraus folgt dass ein AVL Baum mit n blaettern (und n-1 inneren Knoten) eine hoehe aus O(log(n)) hat. Denn jeder AVL-Baum mit hoehe h hat <!-- begin MathToWeb -->
<!-- (your LaTeX) \begin{math}n \geq F_{h+2} \approx c*1.618^{h+2}\end{math} -->
<math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow>
	<mi>n</mi>
	<mo>&#x02265;</mo>
	<msub>
		<mi>F</mi>
		<mrow>
			<mi>h</mi>
			<mo>+</mo>
			<mn>2</mn>
		</mrow>
	</msub>
	<mo>&#x02248;</mo>
	<mi>c</mi>
	<mo>*</mo>
	<mn>1.61</mn>
	<msup>
		<mn>8</mn>
		<mrow>
			<mi>h</mi>
			<mo>+</mo>
			<mn>2</mn>
		</mrow>
	</msup>
</mrow>
</math>
<!-- end MathToWeb --> Blaetter.
\underline{comment}: Es gibt hier noch eine anmerkung auf den folien aber die habe ich rausgelassen. <br>
\underline{Suchen}
Das Suchen in AVL Baeumen erfolgt wie in einem Suchbaum, und ist durch die AVL ausgeglichenheit in O(log(n)) schritten moeglich.

\underline{Einfuegen}
Der schluessel x wird wie beim Suchbaum gemacht. Liegt anschliessend keine AVL eigenschaft mehr vor, so wird sie wiederhergestellt.
<br>
Um die Hoehenbedingung an einen inneren Knoten zu ueberpruefen, <br>
genuegt es einen sogenannten \underline{Balancefaktor} bal(u) mitzufuehren, der wie folgt definiert ist.<br>
bal(u) ist die hoehe des rechten Teilbaumes minus der hoehe des linken Teilbaumes.<br>
In einem AVL Baum gilt fuer jeden inneren Knoten <!-- begin MathToWeb -->
<!-- (your LaTeX) \begin{math}bal(u) \in \lbrace -1,0,1 \rbrace \end{math} -->
<math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow>
	<mi>b</mi>
	<mi>a</mi>
	<mi>l</mi>
	<mrow>
		<mo form="prefix">(</mo>
		<mi>u</mi>
		<mo form="postfix">)</mo>
	</mrow>
	<mo>&#x02208;</mo>
	<mrow>
		<mo form="prefix">&#x0007B;</mo>
		<mo>-</mo>
		<mn>1,0</mn>
		<mn>,1</mn>
		<mo form="postfix">&#x0007D;</mo>
	</mrow>
</mrow>
</math>
<!-- end MathToWeb -->
Sei p der Vater des Blattes bei dem die Suche endet.
\underline{Fall 1 } bal(p) = +1 und x ist kleiner als k(p)
\underline{Fall 2 } bal(p) =-1 und x ist groesser als k(p)
\underline{Fall 3 } bal(p) = 0 und x ist groesser als k(p)
\underline{Fall 4 } bal(p) = 0 und x ist kleiner als k(p)

Durch Einfuegen eines neuen Knotes als rechten oder linken Sohn von p wird p ein Knoten mit Balancefaktor -1 oder +1. Dadurch hat sich die hoehe des Teilbaumes veraendert.<br>
Wir rufen eine Funktion upin(p) fuer den knoten p auf, die den Suchpfad zuruecklaeuft, die Balancefaktoren prueft, gegebenenfalls adjustiert und Umstrukturierungen (sogenannte Rotationen oder Doppelrotationen) vornimmt.

\underline{Invariante}<br>
Wenn upin(p) aufgerufen wird, ist <!-- begin MathToWeb -->
<!-- (your LaTeX) \begin{math}bal(p) \in \lbrace -1, +1 \rbrace \end{math} -->
<math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow>
	<mi>b</mi>
	<mi>a</mi>
	<mi>l</mi>
	<mrow>
		<mo form="prefix">(</mo>
		<mi>p</mi>
		<mo form="postfix">)</mo>
	</mrow>
	<mo>&#x02208;</mo>
	<mrow>
		<mo form="prefix">&#x0007B;</mo>
		<mo>-</mo>
		<mn>1</mn>
		<mo>,</mo>
		<mo>+</mo>
		<mn>1</mn>
		<mo form="postfix">&#x0007D;</mo>
	</mrow>
</mrow>
</math>
<!-- end MathToWeb -->
und die Hoehe des Teilbaumes mit Wurzel p um eins gewachsen.
upin(p) bricht ab, wenn p die Wurzel ist.
Wir unterscheiden zwei Faelle, je nachdem ob p linker oder rechter Sochn seines Vaters ist.<br>
\underline{Fall 1} (p ist linker Sohn seines Vaters <!-- begin MathToWeb -->
<!-- (your LaTeX) \begin{math} \varphi(p)\end{math} -->
<math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow>
	<mi>&#x003C6;</mi>
	<mrow>
		<mo form="prefix">(</mo>
		<mi>p</mi>
		<mo form="postfix">)</mo>
	</mrow>
</mrow>
</math>
<!-- end MathToWeb -->)
\underline{Fall 1.1}(<!-- begin MathToWeb -->
<!-- (your LaTeX) \begin{math} bal(\varphi(p))=+1\end{math} -->
<math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow>
	<mi>b</mi>
	<mi>a</mi>
	<mi>l</mi>
	<mrow>
		<mo form="prefix">(</mo>
		<mi>&#x003C6;</mi>
		<mo form="prefix">(</mo>
		<mi>p</mi>
		<mo form="postfix">)</mo>
		<mo form="postfix">)</mo>
	</mrow>
	<mo>=</mo>
	<mo>+</mo>
	<mn>1</mn>
</mrow>
</math>
<!-- end MathToWeb -->), x wird im linken Teilbaum von p angehangen.
\underline{die vorlesung hat hier ein bild}<br>
Die hoehe des Teilbaumes hat sich nicht veraendert, keine weitere Umstrukturierung notwendig.<br>
\underline{Fall 1.2}(<!-- begin MathToWeb -->
<!-- (your LaTeX) \begin{math} bal(varphi(p))=0\end{math} -->
<math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow>
	<mi>b</mi>
	<mi>a</mi>
	<mi>l</mi>
	<mrow>
		<mo form="prefix">(</mo>
		<mi>v</mi>
		<mi>a</mi>
		<mi>r</mi>
		<mi>p</mi>
		<mi>h</mi>
		<mi>i</mi>
		<mo form="prefix">(</mo>
		<mi>p</mi>
		<mo form="postfix">)</mo>
		<mo form="postfix">)</mo>
	</mrow>
	<mo>=</mo>
	<mn>0</mn>
</mrow>
</math>
<!-- end MathToWeb -->), x wird im linken odre rechten Teilbaum von p angehangen. Die Hoehe des Teilbaumes hat sich nicht veraendert, wir sind fertig.
\underline{Fall 1.3}(<!-- begin MathToWeb -->
<!-- (your LaTeX) \begin{math}bal(\varphi(p))=-1\end{math} -->
<math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow>
	<mi>b</mi>
	<mi>a</mi>
	<mi>l</mi>
	<mrow>
		<mo form="prefix">(</mo>
		<mi>&#x003C6;</mi>
		<mo form="prefix">(</mo>
		<mi>p</mi>
		<mo form="postfix">)</mo>
		<mo form="postfix">)</mo>
	</mrow>
	<mo>=</mo>
	<mo>-</mo>
	<mn>1</mn>
</mrow>
</math>
<!-- end MathToWeb -->)<br>
Da <!-- begin MathToWeb -->
<!-- (your LaTeX) \begin{math}bal(\varphi(p))=-1\end{math} -->
<math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow>
	<mi>b</mi>
	<mi>a</mi>
	<mi>l</mi>
	<mrow>
		<mo form="prefix">(</mo>
		<mi>&#x003C6;</mi>
		<mo form="prefix">(</mo>
		<mi>p</mi>
		<mo form="postfix">)</mo>
		<mo form="postfix">)</mo>
	</mrow>
	<mo>=</mo>
	<mo>-</mo>
	<mn>1</mn>
</mrow>
</math>
<!-- end MathToWeb -->, hatte der linke Teilbaum von <!-- begin MathToWeb -->
<!-- (your LaTeX) \begin{math}\varphi(p)\end{math} -->
<math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow>
	<mi>&#x003C6;</mi>
	<mrow>
		<mo form="prefix">(</mo>
		<mi>p</mi>
		<mo form="postfix">)</mo>
	</mrow>
</mrow>
</math>
<!-- end MathToWeb --> bereits vor dem 
Einfuegen des neuen Schluessels eine um 1 groessere Hoehe als der rechte Teilbaum von <!-- begin MathToWeb -->
<!-- (your LaTeX) \begin{math}\varphi(p)\end{math} -->
<math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow>
	<mi>&#x003C6;</mi>
	<mrow>
		<mo form="prefix">(</mo>
		<mi>p</mi>
		<mo form="postfix">)</mo>
	</mrow>
</mrow>
</math>
<!-- end MathToWeb -->.
Da der linke Teilbaum in der hoehe um eins gewachsen ist, ist die AVL Ausgeglichenheit bei <!-- begin MathToWeb -->
<!-- (your LaTeX) \begin{math}\varphi(p)\end{math} -->
<math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow>
	<mi>&#x003C6;</mi>
	<mrow>
		<mo form="prefix">(</mo>
		<mi>p</mi>
		<mo form="postfix">)</mo>
	</mrow>
</mrow>
</math>
<!-- end MathToWeb --> verletzt.
Wir strukturieren um.
\underline{Fall 1.3.1} (bal(p)=-1)
Hier ist in der vorlesung ein bild.
Nach Vorraussetzung ist der Teilbaum mit Wurzel p um eins gewachsen und der linke Teilbaum von <!-- begin MathToWeb -->
<!-- (your LaTeX) \begin{math}\varphi(p) \end{math} -->
<math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow>
	<mi>&#x003C6;</mi>
	<mrow>
		<mo form="prefix">(</mo>
		<mi>p</mi>
		<mo form="postfix">)</mo>
	</mrow>
</mrow>
</math>
<!-- end MathToWeb -->
um eins groeser als der rechte Teilbaum von <!-- begin MathToWeb -->
<!-- (your LaTeX) \begin{math}\varphi(p)\end{math} -->
<math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow>
	<mi>&#x003C6;</mi>
	<mrow>
		<mo form="prefix">(</mo>
		<mi>p</mi>
		<mo form="postfix">)</mo>
	</mrow>
</mrow>
</math>
<!-- end MathToWeb -->.<br>
Eine \textbf{Rotation} nach rechts bringte den baum bei <!-- begin MathToWeb -->
<!-- (your LaTeX) \begin{math}\varphi(p)\end{math} -->
<math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow>
	<mi>&#x003C6;</mi>
	<mrow>
		<mo form="prefix">(</mo>
		<mi>p</mi>
		<mo form="postfix">)</mo>
	</mrow>
</mrow>
</math>
<!-- end MathToWeb --> wieder in die Balance.
Dabei wird der rechte Teilbaum von p neuer linker Teilbaum von <!-- begin MathToWeb -->
<!-- (your LaTeX) \begin{math}\varphi(p) und \varphi(p) \end{math} -->
<math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow>
	<mi>&#x003C6;</mi>
	<mrow>
		<mo form="prefix">(</mo>
		<mi>p</mi>
		<mo form="postfix">)</mo>
	</mrow>
	<mi>u</mi>
	<mi>n</mi>
	<mo>&#x02146;</mo>
	<mi>&#x003C6;</mi>
	<mrow>
		<mo form="prefix">(</mo>
		<mi>p</mi>
		<mo form="postfix">)</mo>
	</mrow>
</mrow>
</math>
<!-- end MathToWeb --> mit rechtem Teilbaum wird neuer rechter Teilbaum von p.<br>
Da nach der Rotation der Teilbaum mit Wurzel <!-- begin MathToWeb -->
<!-- (your LaTeX) \begin{math}\varphi(p)\end{math} -->
<math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow>
	<mi>&#x003C6;</mi>
	<mrow>
		<mo form="prefix">(</mo>
		<mi>p</mi>
		<mo form="postfix">)</mo>
	</mrow>
</mrow>
</math>
<!-- end MathToWeb --> nicht um eins gewachsen ist, ist eine weitere Umstrukturierung nicht notwendig.
\underline{Fall 1.3.2}(<!-- begin MathToWeb -->
<!-- (your LaTeX) \begin{math}bal(p)=+1\end{math} -->
<math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow>
	<mi>b</mi>
	<mi>a</mi>
	<mi>l</mi>
	<mrow>
		<mo form="prefix">(</mo>
		<mi>p</mi>
		<mo form="postfix">)</mo>
	</mrow>
	<mo>=</mo>
	<mo>+</mo>
	<mn>1</mn>
</mrow>
</math>
<!-- end MathToWeb -->)
Hier ist in der Vorlesung ein Bild<br>
TODO: hier weitermachen mit folie 27/71
\subsection{Splay Baeume}
\subsection{B Baeume}
B Baeume sind balancierte Baumstrukturen. Das Ziel ist es moeglichst selten Bloecke aus dem Plattenspeicher laden zu muessen.
Es wird versucht die Hoehe der Baeume sehr klein zu halten, indem mehrere Schluessel in inneren Knoten gespeichert werden.<br>

Ein B Baum der Ordnung m, m>=3 ist ein Baum mit folgenden Eigenschaften:<br>
Alle Blaetter haben die gleiche Tiefe, Jeder Knoten mit Ausnahme der Wurzel und der Blaetter hat mindestens <!-- begin MathToWeb -->
<!-- (your LaTeX) \begin{math}
\lceil m/2 \rceil 
\end{math} -->
<math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow>
	<mo form="prefix">&#x02308;</mo>
	<mi>m</mi>
	<mo>&#x0002F;</mo>
	<mn>2</mn>
	<mo form="postfix">&#x02309;</mo>
</mrow>
</math>
<!-- end MathToWeb -->
Soehne.
Die Wurzel hat mindestens 2 Soehne. Jeder Knoten hat hoechstens m Soehne. Jeder Knoten mit i Soehnen speichert m-1 Schluessel.<br>

Zusaetzlich gilt:
Ist p ein innerer Knoten eines B Baumes der Ordnung m, so speichert er l schluessel, s1,...,sl und hat l+1 Soehne.
mit <!-- begin MathToWeb -->
<!-- (your LaTeX) \begin{math}
\lceil m/2 \rceil <= l+1 <=m \end{math} -->
<math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow>
	<mrow>
		<mo form="prefix">&#x02308;</mo>
		<mi>m</mi>
		<mo>&#x0002F;</mo>
		<mn>2</mn>
		<mo form="postfix">&#x02309;</mo>
	</mrow>
	<mo>&#x0003C;</mo>
	<mo>=</mo>
	<mi>l</mi>
	<mo>+</mo>
	<mn>1</mn>
	<mo>&#x0003C;</mo>
	<mo>=</mo>
	<mi>m</mi>
</mrow>
</math>
<!-- end MathToWeb -->
Alle Schluessel im Teilbaum mit wurzel
<!-- begin MathToWeb -->
<!-- (your LaTeX) \begin{math}
 p_{i-1}, 1 \leq i \leq l \end{math} -->
<math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow>
	<msub>
		<mi>p</mi>
		<mrow>
			<mi>i</mi>
			<mo>-</mo>
			<mn>1</mn>
		</mrow>
	</msub>
	<mn>,1</mn>
	<mo>&#x02264;</mo>
	<mi>i</mi>
	<mo>&#x02264;</mo>
	<mi>l</mi>
</mrow>
</math>
<!-- end MathToWeb --> sind kleiner als si und alle Schluessel im Teilbaum mit Wurzel pi sind groesser als si.<br>
Bemerkung: Ein B Baum der n Schluessel speichert hat n+1 Blaetter.<br>
Ein B Baum der Ordnung m mit hoehe h hat die minimale Blattanzahl wenn seine Wurzel nur 2 und jeder innere Knoten nur <!-- begin MathToWeb -->
<!-- (your LaTeX) \begin{math}
\lceil m/2 \rceil 
\end{math} -->
<math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow>
	<mo form="prefix">&#x02308;</mo>
	<mi>m</mi>
	<mo>&#x0002F;</mo>
	<mn>2</mn>
	<mo form="postfix">&#x02309;</mo>
</mrow>
</math>
<!-- end MathToWeb --> 
viele Soehne hat.

<!-- %here is some content missing i thought not important -->
B Baeume sind balanciert.
\subsubsection{Suchen in B Baeumen}
Man beginnt mit der Wurzel, die die Schluessel <!-- begin MathToWeb -->
<!-- (your LaTeX) \begin{math}
 s_{1}, ... ,s_{l}
\end{math} -->
<math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow>
	<msub>
		<mi>s</mi>
		<mn>1</mn>
	</msub>
	<mo>,</mo>
	<mo>.</mo>
	<mo>.</mo>
	<mo>.</mo>
	<mo>,</mo>
	<msub>
		<mi>s</mi>
		<mi>l</mi>
	</msub>
</mrow>
</math>
<!-- end MathToWeb --> speichert und bestimmt einen kleinsten index i mit <!-- begin MathToWeb -->
<!-- (your LaTeX) \begin{math}
 x \leq s_{i} 
\end{math} -->
<math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow>
	<mi>x</mi>
	<mo>&#x02264;</mo>
	<msub>
		<mi>s</mi>
		<mi>i</mi>
	</msub>
</mrow>
</math>
<!-- end MathToWeb -->
falls es ein solches i gibt. Ist x = si so ist x gefunden.
Ist x < si so setze die suche bei p i-1 fort, im fall x > si setze die suche bei pi fort.
Das wird solange gemacht bis man x gefunden hat.
\subsubsection{Einfuegen in B Baum}
\subsubsection{Entfernen in B Baum}
Zum Entfernen eines Schluessels x wird x zunaechst gesucht. wird x nicht gefunden, ist nichts zu tun.
\textbf{Fall 1: x ist Schluessel si eines Knotens und pi-1, pi sind keine Blaetter.}
Dann suche den groessten Schluessel y im Teilbaum mit wurzel pi-1
bzw den kleinsten Schluessel y im Teilbaum mit wurzel pi und tausche ihn mit x.
Entferne dann x wi in Fall 2.

\textbf{Fall2: x ist Schluessel si eines Knotens und <!-- begin MathToWeb -->
<!-- (your LaTeX) \begin{math}
p_{i-1}, p_{i} \end{math} -->
<math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow>
	<msub>
		<mi>p</mi>
		<mrow>
			<mi>i</mi>
			<mo>-</mo>
			<mn>1</mn>
		</mrow>
	</msub>
	<mo>,</mo>
	<msub>
		<mi>p</mi>
		<mi>i</mi>
	</msub>
</mrow>
</math>
<!-- end MathToWeb --> sind blaetter.}

Entferne x und das blatt pi-1 oder pi.
Falls der dabei entstandene Knoten p weniger als <!-- begin MathToWeb -->
<!-- (your LaTeX) \begin{math}
 \lceil \frac{m}{2} \rceil -1 
\end{math} -->
<math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow>
	<mrow>
		<mo form="prefix">&#x02308;</mo>
		<mfrac linethickness="1">
			<mi>m</mi>
			<mn>2</mn>
		</mfrac>
		<mo form="postfix">&#x02309;</mo>
	</mrow>
	<mo>-</mo>
	<mn>1</mn>
</mrow>
</math>
<!-- end MathToWeb -->
Schluessel hat, sei q der linke oder rechte Bruder von p, je nachdem welcher Bruder existiert. 
OBdA ist q linker Bruder von p.

Sei y der Schluessel im Vater r, der zwischen q und p angeordnet ist. 
Wir speichern nun die Schluessel von q,y,p in einem neuen Knoten p' <br>
Dazu wird y aus dem Vater r entfernt.

\subparagraph{Fall 2.1:}
Sind <!-- begin MathToWeb -->
<!-- (your LaTeX) \begin{math} k_{1} ..., k_{l} \end{math} -->
<math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow>
	<msub>
		<mi>k</mi>
		<mn>1</mn>
	</msub>
	<mo>.</mo>
	<mo>.</mo>
	<mo>.</mo>
	<mo>,</mo>
	<msub>
		<mi>k</mi>
		<mi>l</mi>
	</msub>
</mrow>
</math>
<!-- end MathToWeb --> die Schluessel in p' in aufsteigender Reihenfolge und ist <!-- begin MathToWeb -->
<!-- (your LaTeX) \begin{math}l > m-1 \end{math} -->
<math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow>
	<mi>l</mi>
	<mo>&#x0003E;</mo>
	<mi>m</mi>
	<mo>-</mo>
	<mn>1</mn>
</mrow>
</math>
<!-- end MathToWeb -->so bildet man zwei neue Knoten p,q
mit den Schluesseln <!-- begin MathToWeb -->
<!-- (your LaTeX) \begin{math} k_{1},...,k_{\frac{l}{2}} \end{math} -->
<math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow>
	<msub>
		<mi>k</mi>
		<mn>1</mn>
	</msub>
	<mo>,</mo>
	<mo>.</mo>
	<mo>.</mo>
	<mo>.</mo>
	<mo>,</mo>
	<msub>
		<mi>k</mi>
		<mrow>
			<mfrac linethickness="1">
				<mi>l</mi>
				<mn>2</mn>
			</mfrac>
		</mrow>
	</msub>
</mrow>
</math>
<!-- end MathToWeb --> und <!-- begin MathToWeb -->
<!-- (your LaTeX) \begin{math} k_{\frac{l}{2}+1},...,k_{l} \end{math} -->
<math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow>
	<msub>
		<mi>k</mi>
		<mrow>
			<mfrac linethickness="1">
				<mi>l</mi>
				<mn>2</mn>
			</mfrac>
			<mo>+</mo>
			<mn>1</mn>
		</mrow>
	</msub>
	<mo>,</mo>
	<mo>.</mo>
	<mo>.</mo>
	<mo>.</mo>
	<mo>,</mo>
	<msub>
		<mi>k</mi>
		<mi>l</mi>
	</msub>
</mrow>
</math>
<!-- end MathToWeb -->
und fuegt den mittleren Schluessel <!-- begin MathToWeb -->
<!-- (your LaTeX) \begin{math} k_{\frac{l}{2}} \end{math} -->
<math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow>
	<msub>
		<mi>k</mi>
		<mrow>
			<mfrac linethickness="1">
				<mi>l</mi>
				<mn>2</mn>
			</mfrac>
		</mrow>
	</msub>
</mrow>
</math>
<!-- end MathToWeb --> im Vater r zwischen q,p ein.
\subparagraph{Fall 2.2:} Ist <!-- begin MathToWeb -->
<!-- (your LaTeX) \begin{math}
 l \leq m-1
\end{math} -->
<math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow>
	<mi>l</mi>
	<mo>&#x02264;</mo>
	<mi>m</mi>
	<mo>-</mo>
	<mn>1</mn>
</mrow>
</math>
<!-- end MathToWeb --> dann muss der Vater r von p' weiter betrachtet werden, weil er moeglicherweise zu wenig schluessel speichert.
Die Korrekturen der zu klein gewordenen Knoten setzen sich entlag des Suchpfades gegebenenfalls bis zur Wurzel fort.

\section{Vorlesung 7: Graphen}
Ein Graph <!-- begin MathToWeb -->
<!-- (your LaTeX) \begin{math} G=\lbrace V,E\rbrace \end{math} -->
<math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow>
	<mi>G</mi>
	<mo>=</mo>
	<mrow>
		<mo form="prefix">&#x0007B;</mo>
		<mi>V</mi>
		<mo>,</mo>
		<mi>E</mi>
		<mo form="postfix">&#x0007D;</mo>
	</mrow>
</mrow>
</math>
<!-- end MathToWeb --> besteht aus einer endlichen menge von knoten V und kanten E.

In einem gerichteten Graphen ist jede Kante e ein Paar (u,v) von zwei knoten u,v elem V, u ist der startknoten und v der Endknoten.
$$ E \subset V x V $$
\subsection{2}
In einem ungerichteten Graphen ist jede Kante e 
\section{Runtime Analysis}
\section{Showing Correctness of an Algorithm}
\url{http://www.cs.cornell.edu/courses/cs211/2006sp/Lectures/L06-Induction/binary_search.html}<br>

\textbf{Showing binary search correct using strong induction }<br>
Strong induction<br>

Strong (or course-of-values) induction is an easier proof technique than ordinary induction because you get to make a stronger assumption in the inductive step. In that step, you are to prove that the proposition holds for k+1 assuming that that it holds for all numbers from 0 up to k. This stronger assumption is especially useful for showing that many recursive algorithms work.

\textbf{The recipe for strong induction is as follows:}

    State the proposition P(n) that you are trying to prove to be true for all n.
    Base case: Prove that the proposition holds for n = 0, i.e., prove that P(0) is true.
    Inductive step: Assuming the induction hypothesis that P(n) holds for all n between 0 and k, prove that P(k+1) is true.
    Conclude by strong induction that P(n) holds for all n ??? 0. 

\textbf{Example: Binary Search}

For example, consider a binary search algorithm that searches efficiently for an element contained in a sorted array. We might implement this algorithm recursively as follows:<br>

\begin{verbatim}
/** Return an index of x in a.
 *  Requires: a is sorted in ascending order, and x is found in the array a
 *  somewhere between indices left and right.
 */
int binsrch(int x, int[] a, int left, int right) {
    int m = (left+right)/2;
    if (x == a[m]){
        return m;
    }
    if (x < a[m]){
        return find(x, a, l, m???1)
    }else{
        return find(x, a, m+1, r);
    }
}
\end{verbatim}

Because this code is tail-recursive, we can also transform it into iterative code straightforwardly:
\begin{verbatim}
int binsrch(int x, int[] a, int left, int right) {
    while (true) {
        int m = (left+right)/2;
        if (x == a[m]){
            return m;
        }
        if (x < a[m]){
            r = m???1;
        }else{
            l = m+1;
        }
    }
}
\end{verbatim}

Binary search is efficient and easy to understand, but it is also famously easy to implement incorrectly. So it is a good example of code for which we want to think carefully about whether it works. Just testing it may well miss cases in which it does not work correctly.<br>

We can prove either piece of code correct by induction, but it is arguably simpler to think about the recursive version. The problem with convincing ourselves that binsrch works is that it uses itself, so the argument becomes circular if we're not careful. The key observation is that binsrch works in a divide-and-conquer fashion, calling itself only on arguments that are ???smaller??? in some way. In what way do the arguments become smaller? The difference between the parameters right and left becomes smaller in the recursive call. This is then the variable we should choose to construct our inductive argument. Now we can follow the strong induction recipe.<br>

Let P(n) be the assertion that binsrch works correctly for inputs where <!-- begin MathToWeb -->
<!-- (your LaTeX) \begin{math}right???left = n\end{math} -->
<math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow>
	<mi>r</mi>
	<mi>i</mi>
	<mi>g</mi>
	<mi>h</mi>
	<mi>t</mi>
	???<mi>l</mi>
	<mi>e</mi>
	<mi>f</mi>
	<mi>t</mi>
	<mo>=</mo>
	<mi>n</mi>
</mrow>
</math>
<!-- end MathToWeb -->. 
If we can prove that P(n) is true for all n, then we know that binsrch works on all possible arguments.<br>

\textbf{Base Case}. In the case where n=0, we know left=right=m. Since we assumed that the function would only be called when x is found between left and right, it must be the case that x = a[m], and therefore the function will return m, an index of x in array a.<br>

\textbf{Inductive Step}. We assume that binsrch works as long as left???right ??? k. Our goal is to prove that it works on an input where left???right = k + 1. There are three cases, where x = a[m], where x < a[m] and where x > a[m].<br>
\textbf{Case x = a[m]}. <br>Clearly the function works correctly.<br>
\textbf{Case x < a[m]}. <br>We know because the array is sorted that x must be found between a[left] and a[m???-1]. So if the recursive call works correctly, this call will too. The n for the recursive call is n = m ??? 1 ??? left = ???(left+right)/2??? ??? 1 ??? left. (Note that ???x??? is the floor of x, which rounds it down toward negative infinity.) If left+right is odd, then n = (left + right ??? 1)/2 ??? 1 ??? left = (right ??? left)/2 ??? 1, which is definitely smaller than right???left. If left+right is even then n = (left + right)/2 ??? 1 ??? left = (right???left)/2, which is also smaller than k + 1 = right???left because right???left = k + 1 > 0. So the recursive call must be to a range of a that is between 0 and k cells, and must be correct by our induction hypothesis.<br>

\textbf{Case <!-- begin MathToWeb -->
<!-- (your LaTeX) \begin{math}x > a[m]\end{math} -->
<math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow>
	<mi>x</mi>
	<mo>&#x0003E;</mo>
	<mi>a</mi>
	<mrow>
		<mo form="prefix">[</mo>
		<mi>m</mi>
		<mo form="postfix">]</mo>
	</mrow>
</mrow>
</math>
<!-- end MathToWeb -->}. <br>
This is more or less symmetrical to the previous case. <br>
We need to show that r ??? (m + 1) ??? right ??? left. 
We have <!-- begin MathToWeb -->
<!-- (your LaTeX) \begin{equation}r???(m + 1)???l=right???\lfloor(left+right)/2\rfloor-1\end{equation} -->
<math xmlns="http://www.w3.org/1998/Math/MathML">
<mtable class="m-equation" displaystyle="true" style="display: block; margin-top: 1.0em; margin-bottom: 2.0em">
	<mtr>
		<mtd>
			<mspace width="6.0em" />
		</mtd>
		<mtd columnalign="left">
			<mi>r</mi>
			???
			<mrow>
				<mo form="prefix">(</mo>
				<mi>m</mi>
				<mo>+</mo>
				<mn>1</mn>
				<mo form="postfix">)</mo>
			</mrow>
			???<mi>l</mi>
			<mo>=</mo>
			<mi>r</mi>
			<mi>i</mi>
			<mi>g</mi>
			<mi>h</mi>
			<mi>t</mi>
			???
			<mrow>
				<mo form="prefix">&#x0230A;</mo>
				<mrow>
					<mo form="prefix">(</mo>
					<mi>l</mi>
					<mi>e</mi>
					<mi>f</mi>
					<mi>t</mi>
					<mo>+</mo>
					<mi>r</mi>
					<mi>i</mi>
					<mi>g</mi>
					<mi>h</mi>
					<mi>t</mi>
					<mo form="postfix">)</mo>
				</mrow>
				<mo>&#x0002F;</mo>
				<mn>2</mn>
				<mo form="postfix">&#x0230B;</mo>
			</mrow>
			<mo>-</mo>
			<mn>1</mn>
		</mtd>
		<mtd columnalign="right" style="width: 100%">
			<mtext id="">(1)</mtext>
			<mspace width="6.0em" />
		</mtd>
	</mtr>
</mtable>
</math>
<!-- end MathToWeb -->.<br>

If right+left is even, this is (right???left)/2 ??? 1, which is less than right???left. If right+left is odd, this is right??? (left + right ??? 1)/2 ??? 1 = (right???left)/2 ??? 1/2, which is also less than right???left. Therefore, the recursive call is to a smaller range of the array and can be assumed to work correctly by the induction hypothesis. <br>

Because in all cases the inductive step works, we can conclude that binsrch (and its iterative variant) are correct! 
<br>
Notice that if we had made a mistake coding the <!-- begin MathToWeb -->
<!-- (your LaTeX) \begin{math}x > a[m]\end{math} -->
<math xmlns="http://www.w3.org/1998/Math/MathML">
<mrow>
	<mi>x</mi>
	<mo>&#x0003E;</mo>
	<mi>a</mi>
	<mrow>
		<mo form="prefix">[</mo>
		<mi>m</mi>
		<mo form="postfix">]</mo>
	</mrow>
</mrow>
</math>
<!-- end MathToWeb --> case, and passed m as left instead of m+1 (easy to do!), the proof we just constructed would have failed in that case. And in fact, the algorithm could go into an infinite loop when right = left + 1. This shows the value of careful inductive reasoning. 


<h1> Resources </h1>
khanacademy.com<br>
codewars.com<br>
github.com<br>
onlinetutorium.com<br>
sharelatex.com<br>
hackerrank.com<br>
brilliant.org<br>
https://www.w3schools.com/<br>
freecodecamp.com<br>

<h1>Algodat</h1>
<a href="https://www.cs.usfca.edu/~galles/visualization/AVLtree.html"></a>
<br>
https://www.cs.usfca.edu/~galles/visualization/Algorithms.html
<br>
https://www.youtube.com/watch?v=dHYX4dtNS1k

<h1>Theoretical Computer Science</h1>
An Alphabet $ \Sigma $ is a finite, non-empty Set.<br>
Elements of this Set are called Letters.<br>

A Word $ w $ over $ \Sigma $ is a finite (and possibly empty) sequence of Letters from $ \Sigma$ <br>

<hr>

<h1>Theoretische Informatik SoSe 2019, Blatt 3 </h1>
<h2>Aufgabe 1 : Chomsky Hierarchie:</h2>
Geben sie fuer folgende Spachen jeweils<br>
(i) eine Grammatik $G_{i}$ mit $L(G_{i}) = L_{i}, 1\leq i \leq 3$
und moeglichst grossem Typ an und 
<br>
(ii) geben sie explizit den maximalen Typ ihrer Grammatik an. 
<br>
Begruenden sie ihre Antworten, insbesondere, warum Ihre Grammatik von keinem groesseren Typ ist.
<br>
<br>
(a) $L_{1} = \{ 1^{n} 0^{m} | n,m \geq 2 \} \subseteq \{0,1\}^{*} $
<br>
(b) $L_{2} = \{ 0^{2n}110(01)^{n} | n \geq 0 \} \subseteq \{0,1\}^{*} $
<br>
(c) $L_{3} = \{ aba^{n+2}ba | n \geq 0 \} \subseteq \{a,b\}^{*} $
<br>

<h2> Aufgabe1: mein Ergebnis </h2>
<br>
(a) $G_{1} = ({},N,S,T) $
<hr>

When $a \ne 0$, there are two solutions to \(ax^2 + bx + c = 0\) and they are
$$x = {-b \pm \sqrt{b^2-4ac} \over 2a}.$$
$$ \begin{array}{rcll}
y & = & x^{2}+bx+c<br>
  & = & x^{2}+2\times\dfrac{b}{2}x+c<br>
  & = & \underbrace{x^{2}+2\times\dfrac{b}{2}x+\left(\frac{b}{2}\right)^{2}}-
      {\left(\dfrac{b}{2}\right)^{2}+c}<br>
  &  & \qquad\left(x+{\dfrac{b}{2}}\right)^{2}<br>
  & = & \left(x+\dfrac{b}{2}\right)^{2}-\left(\dfrac{b}{2}\right)^{2}+c 
  & \left|+\left({\dfrac{b}{2}}\right)^{2}-c\right.<br>
    y+\left(\dfrac{b}{2}\right)^{2}-c & = & \left(x+
    \dfrac{b}{2}\right)^{2} & \left|\strut(\textrm{vertex form})\right.<br>
y-y_{S} & = & (x-x_{S})^{2}<br>
S(x_{S};y_{S}) & \,\textrm{or}\, 
    & S\left(-\dfrac{b}{2};\,\left(\dfrac{b}{2}\right)^{2}-c\right)
\end{array} $$

